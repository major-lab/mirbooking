#!/usr/bin/env python3

import numpy as np
from concurrent.futures import ProcessPoolExecutor
from subprocess import Popen, PIPE
import argparse
import shlex
from itertools import product
from tqdm import tqdm, TqdmSynchronisationWarning
import warnings
warnings.simplefilter('ignore', TqdmSynchronisationWarning)

parser = argparse.ArgumentParser()
parser.add_argument('--mcff', type=str, default='mcff', help='Location of the MC-Flashfold binary')
parser.add_argument('--mcff-args', type=str, default='', help='Extra arguments for MC-Flashfold')
parser.add_argument('--seed-length', type=int, default=7, help='Seed length')
parser.add_argument('--max-mismatches', type=int, default=1, help='Maximum number of mismatches')
parser.add_argument('--max-workers', type=int, default=1, help='Number of workers')
parser.add_argument('--output', type=str, required=True, help='Path to the output table')
args = parser.parse_args()

mcff = args.mcff
mcff_args = shlex.split(args.mcff_args)
max_workers = args.max_workers
max_mismatches = args.max_mismatches
seed_len = args.seed_length
output = args.output

@np.vectorize
def to_seed(x, seed_length=7):
    def _tobase(x):
        return (_tobase(x // 4) if x > 3 else '') + 'ACGT'[x % 4]
    return _tobase(x).rjust(seed_length, 'A')

def duplex_energy(a, b):
    # FIXME: use check_call
    proc = Popen([mcff, '-seq', a, '-zzd', b] + mcff_args, stdout=PIPE)
    return float(proc.communicate()[0])

table = np.memmap(output, dtype='>f', mode='w+', shape=(4**seed_len, 4**seed_len))

seeds = to_seed(range(4**seed_len), seed_length=seed_len)
T = str.maketrans('ATCG', 'TAGC')

@np.vectorize
def reverse_seed(seed):
    return ''.join(reversed(seed))

seeds = to_seed(range(4**seed_len))
seeds_rc = reverse_seed(np.char.translate(seeds, T))

with ProcessPoolExecutor(max_workers=max_workers) as executor:
    def work(i):
        mir_seed = seeds[i]
        mir_seed_rc = seeds_rc[i]
        for j in range(4**seed_len):
            mre_seed = seeds[j]
            # Hamming distance to estimate mismatches bound
            mismatches = sum(mre_seed[k] != mir_seed_rc[k] for k in range(seed_len))
            if mismatches <= max_mismatches:
                table[i,j] = duplex_energy(mre_seed, # MRE as base
                                           mir_seed) # seed
            else:
                table[i,j] = np.inf
    for _ in tqdm(executor.map(work, range(4**seed_len)), total=4**seed_len):
        pass