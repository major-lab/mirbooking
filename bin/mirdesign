#!/usr/bin/env python3

import argparse
import numpy as np
import os
import pandas as pd
import random
import subprocess
import sys
import tempfile
import threading

from Bio.Seq import Seq
from Bio.SeqIO import SeqRecord, write
from collections import defaultdict
from io import StringIO
from os.path import join, exists
from queue import PriorityQueue, Empty
from scipy.special import logit
from subprocess import check_output
from threading import Thread, Lock
from tqdm import tqdm

parser = argparse.ArgumentParser()

parser.add_argument('--target', action='append', help='Target transcripts or everything if not specified')
parser.add_argument('--non-target', action='append', help='Non-target transcripts')
parser.add_argument('--initial-candidate', help='Initial candidate')
parser.add_argument('--alpha', type=float, default=0.1, help='Heuristic weight')
parser.add_argument('--workers', type=int, default=2, help='Number of workers spawning processes')
parser.add_argument('--threads-per-worker', type=int, default=1, help='Number of threads per worker')
parser.add_argument('--design-quantity', type=float, default=1e4, help='Design concentration')
parser.add_argument('--designs-output-dir', required=True)

parser.add_argument('--mirbooking', default='mirbooking', help='Location of miRBooking binary')
parser.add_argument('--input', required=True, help=argparse.SUPPRESS)

args, mirbooking_args = parser.parse_known_args()

if args.initial_candidate is None:
    args.initial_candidate = 22 * 'N'

os.environ['OMP_NUM_THREADS'] = str(args.threads_per_worker)

def run_mirbooking(candidate, quantities, q=args.design_quantity):
    quantities = quantities.copy()
    quantities.loc['smart','quantity'] = q
    # TODO: use a named pipe to bypass the filesystem
    with tempfile.NamedTemporaryFile(dir='/dev/shm') as design_file:
        write([SeqRecord(Seq(candidate), 'smart')], design_file.name, format='fasta')
        return pd.read_csv(StringIO(check_output([args.mirbooking] + mirbooking_args + ['--mirnas', design_file.name], input=quantities.to_csv(sep='\t'), universal_newlines=True)), index_col=['target_accession', 'position', 'mirna_accession'], sep='\t')

def expressed_fraction(df):
    # fraction of targets without any microRNA bound (following Poisson-Binomial model)
    target_with_pos = df.groupby(level=[0,1]).agg({'target_quantity': 'first', 'quantity': 'sum'})
    assert (target_with_pos.quantity <= target_with_pos.target_quantity).all()
    return (1 - (target_with_pos.quantity / target_with_pos.target_quantity)).groupby(level=0).prod()

def seed(design):
    return str(design[1:8])

quantities = pd.read_csv(args.input, index_col=0, sep='\t')
def evaluate(candidate):
    if 'N' in seed(candidate):
        return 0

    df = run_mirbooking(candidate, quantities)

    if args.target is None and args.non_target is None:
        # if no target/non-target are specified, default to target everything mode
        t_ef = expressed_fraction(df).reindex(quantities.index).fillna(0.5)
    elif args.target is None:
        t_ef = np.array([0.5])
    else:
        t_ef = expressed_fraction(df).reindex(args.target).fillna(0.5)

    if args.non_target is None:
        nt_ef = np.array([0.5])
    else:
        nt_ef = expressed_fraction(df).reindex(args.non_target).fillna(0.5)

    return logit(t_ef).mean() - logit(nt_ef).mean()

positions = list(range(1, 8)) + list(range(11, 14)) + list(range(14,17)) + list(range(8, 11)) + list(range(17, 20))

def heuristic(seq, score):
    if 'N' in seed(seq):
        return float('-inf')
    chosen = sum(seq[p] != 'N' for p in positions)
    remaining = sum(seq[p] == 'N' for p in positions)
    if chosen == 0:
        return score
    return score * (remaining / chosen)

def successors(candidate):
    for p in positions:
        if candidate[p] == 'N':
            s = [candidate[:p] + nt + candidate[p+1:]
                       for nt in ['A', 'C', 'G', 'T']]
            random.shuffle(s)
            return s
    return [] # no successors

best_candidate = None
best_score = float('inf')

counter = 1
pruned = 0
def work(candidates, pb, designs_out):
    global counter, best_candidate, best_score, pruned
    while True:
        item = candidates.get()
        heuristic_score, candidate_score, _, candidate = item

        if candidate_score < best_score:
            best_candidate = candidate
            best_score = candidate_score

        if best_candidate:
            pb.set_postfix(current_design=candidate, current_score=f'{candidate_score:.2f} ({heuristic_score:.2f})', best_design=best_candidate, best_score=best_score, queued=candidates.qsize(), pruned=pruned)
        else:
            pb.set_postfix(current_design=candidate, current_score=f'{candidate_score:.2f} ({heuristic_score:.2f})', queued=candidates.qsize(), pruned=pruned)

        has_successor = False
        for s in successors(candidate):
            try:
                successor_score = evaluate(s)
            except Exception as err:
                pb.write(f'Failed to process candidate: {s}')
                if hasattr(err, 'output'):
                    pb.write(err.output)
                continue
            finally:
                pb.update()

            # The heuristic simply project linearly the gain so far on the
            # remaining nucleotides. With the monotonicity condition that
            # arises from Yan et al. 2018 model, this is guaranteed to be
            # admissible.
            heuristic_score = successor_score + args.alpha * heuristic(s, successor_score)

            if heuristic_score < best_score or 'N' in seed(candidate):
                # It's possible that all successors end-up pruned (or fail to
                # evaluate), in which case we would have a terminal node.
                has_successor = True
                candidates.put((heuristic_score, successor_score, counter, s))
                counter += 1
            else:
                pruned += 1

        # terminal design
        if not has_successor:
            microtargetome_out = join(args.designs_output_dir, candidate)
            # It's possible that the design has already been found in a
            # previous execution
            if not exists(microtargetome_out):
                run_mirbooking(candidate, quantities).to_csv(microtargetome_out, sep='\t')
                print(candidate, candidate_score, sep='\t', file=designs_out, flush=True)

        candidates.task_done()

with tqdm() as pb, open(join(args.designs_output_dir, 'designs.tsv'), 'a') as f:
    candidates = PriorityQueue()

    # prepare workers
    threads = [Thread(target=work, args=(candidates, pb, f), daemon=True) for t in range(args.workers)]
    for t in threads:
        t.start()

    # add initial candidates
    candidate = args.initial_candidate
    score = evaluate(candidate)
    candidates.put((score + args.alpha * heuristic(candidate, score), score, counter, candidate))
    counter += 1
    pb.update()

    # wait until all workers are done
    candidates.join()
