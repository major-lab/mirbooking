#!/usr/bin/env python3

import pandas as pd
import argparse
import sys

SAMPLE_MODES = ['weighted', 'uniform', 'top']

parser = argparse.ArgumentParser(description='Prepare a quantification subset')
parser.add_argument('--input', default=sys.stdin)
parser.add_argument('--output', default=sys.stdout)
parser.add_argument('--kappa', type=float, default=2.26, help='pM/FPKM ratio')
parser.add_argument('--eta', type=float, default=10, help='miRNA:mRNA ratio')
parser.add_argument('--num-mirnas', type=int, help='Number of microRNAs to pick (all if unspecified)')
parser.add_argument('--num-targets', type=int, help='Number of targets to pick (all if unspecified)')
parser.add_argument('--mirnas-sample-mode', type=str, choices=SAMPLE_MODES, default=None, help='Sample mode for microRNAs')
parser.add_argument('--targets-sample-mode', type=str, choices=SAMPLE_MODES, default=None, help='Sample mode for targets')
parser.add_argument('--random-state', type=int, help='Random state used for sampling')

args = parser.parse_args()

quantities = pd.read_csv(args.input, sep='\t', index_col=0)

mirnas = quantities.index.str.startswith('MIMAT') | quantities.index.str.startswith('SYNTH')

# convert original units into pM
quantities['quantity'] *= kappa

# adjust miR:mRNA ratio
quantities.loc[mirnas, 'quantity'] *= args.eta * quantities[~mirnas].quantity.sum() / quantities[mirnas].quantity.sum()

def sample(df, n, mode, random_state):
    if n is None:
        return df
    if mode == 'top':
        return df.sort_values('quantity', ascending=False).head(n)
    else:
        return df.sample(n, weights='quantity' if mode == 'weighted' else None, random_state=random_state)

m = sample(quantities[mirnas], args.num_mirnas, args.mirnas_sample_mode, args.random_state)
t = sample(quantities[~mirnas], args.num_targets, args.targets_sample_mode, args.random_state)

# adjust effective cross-concentration
actual_mq = m.sum() / quantities[mirnas].sum()
actual_tq = t.sum() / quantities[~mirnas].sum()

t *= actual_mq
m *= actual_tq

pd.concat([t, m]).to_csv(args.output, sep='\t')
