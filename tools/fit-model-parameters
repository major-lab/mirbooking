#!/usr/bin/env python3

#
# This scripts reproduce the default biochemical model used by miRBooking to
# characterize individual interactions in such a way we can fit the free
# parameters with experimental data.
#

from concurrent.futures import ProcessPoolExecutor
from math import isfinite, isnan
from random import sample, seed
from scipy.optimize import minimize
from scipy.special import logit, expit
from scipy.stats import pearsonr
from subprocess import check_output, DEVNULL
from tqdm import tqdm
import argparse
import numpy as np
import re
import sys
import warnings
import yaml

warnings.filterwarnings('ignore')

seed(123)

parser = argparse.ArgumentParser()
parser.add_argument('--supplementary-model', choices=['wee-et-al-2012', 'yan-et-al-2018'])
parser.add_argument('--min-central-bulge-size', type=int, default=0)
parser.add_argument('--max-central-bulge-size', type=int, default=0)
parser.add_argument('--sample-size', type=int)
parser.add_argument('input')
args = parser.parse_args()

R = 1.987203611e-3
T = 310.5

def fold(a, b):
    vienna_binding_energy_re = 'delta G binding=\s*(.+)$'
    input_fasta = f'{a}&{b}'
    stdout = check_output(['RNAcofold', '--noPS', '-p'], input=input_fasta, universal_newlines=True, stderr=DEVNULL)
    match = re.search(vienna_binding_energy_re, stdout)
    ret = float(match.group(1))
    if not isfinite(ret):
        return 0
    else:
        return ret

def rc(a):
    return a.upper().translate(str.maketrans('ACGT', 'TGCA'))

def binding_energy(G, axis=None):
    G = np.array(G)
    Z = np.sum(np.exp(-G / (R * T)), axis=axis)
    return np.sum(np.exp(-G/(R*T)) * G, axis=axis) / Z

def binding_probability(G):
    G = np.array(G)
    Z = np.sum(np.exp(-G / (R * T)))
    return np.exp(-G/(R*T)) / Z

def process_experiment(experiment):
    target, position, mirna = experiment['target'], experiment['position'], experiment['mirna']

    min_bulge = args.min_central_bulge_size
    max_bulge = args.max_central_bulge_size
    central_bulge_size = 0

    seed_energy = fold(target[position:position+7], mirna[1:8])

    # look for G nucleation bulge
    if target[position+3] == 'G':
        seed_energy = binding_energy([seed_energy, fold(target[position:position+3] + target[position+4:position+8], mirna[1:8]) + 1.2])

    # Wee et al. 2012
    if args.supplementary_model == 'wee-et-al-2012':
        # find the best bulge to anchor the supplementary
        best_supplementary = float('inf')
        for bulge_size in range(min_bulge, max_bulge + 1):
            supplementary = fold(target[position-8-bulge_size:position-8-bulge_size+4], mirna[12:16])
            if supplementary < best_supplementary:
                best_supplementary = supplementary
                central_bulge_size = bulge_size

                if central_bulge_size == 0:
                    central = fold(target[position-bulge_size-4:position-4+4], mirna[8:12])
                else:
                    central = 0.

                tail_canonical_ensemble = [supplementary, supplementary + central]

        tail_energy = binding_energy(tail_canonical_ensemble)
        if central_bulge_size == 0:
            cleavage_probability = binding_probability(tail_canonical_ensemble)[1]
        else:
            cleavage_probability = 0

    # Yan et al. 2018
    elif args.supplementary_model == 'yan-et-al-2018':
        # find the best bulge to anchor the B-box and zip the remaining nucleotides
        best_B = float('inf')
        for bulge_size in range(min_bulge, max_bulge + 1):
            B = fold(target[position-bulge_size-6:position-bulge_size-6+3], mirna[11:14])
            if B < best_B:
                best_B = B
                central_bulge_size = bulge_size

                if central_bulge_size == 0:
                    A = fold(target[position-bulge_size-4:position-4+4], mirna[8:12])
                else:
                    A = 0.

                C = fold(target[position-bulge_size-9:position-bulge_size-9+3], mirna[14:17])
                D = fold(target[position-bulge_size-12:position-bulge_size-12+3], mirna[17:17+3])
                tail_canonical_ensemble = [B, B + C, B + C + A, B + C + A + D]

        tail_energy = binding_energy(tail_canonical_ensemble)
        if central_bulge_size == 0:
            cleavage_probability = np.sum(binding_probability(tail_canonical_ensemble)[2:])
        else:
            cleavage_probability = 0

    else:
        tail_energy = 0
        cleavage_probability = 0

    X = [target[position + 7] == 'A', # t1 adenosine
         seed_energy,                 # seed
         central_bulge_size,              # central bulge size on target
         tail_energy,                 # supplementary energy
         cleavage_probability]        # fraction of cleavage-competent secondary structures

    # kf mismatch penalties
    X.extend(target[position + 7 - i] != rc(mirna[i]) for i in range(0, 8))

    score = experiment['score']

    kf = float(score.get('kf', ['nan'])[0])
    kr = float(score.get('kr', ['nan'])[0])
    kcat = float(score.get('kcat', ['nan'])[0])
    Kd = float(score.get('Kd', ['nan'])[0])
    Km = float(score.get('Km', ['nan'])[0])

    if isnan(kr):
        kr = kf * Kd

    if isnan(kf):
        kf = kr/Kd

    if isnan(Kd):
        Kd = kr/kf

    if isnan(Km):
        Km = Kd + kcat/kf

    Y = [kf, kr, kcat, Kd, Km]

    return X, Y

with open(args.input) as f:
    data = yaml.load(f, Loader=yaml.FullLoader)
    if args.sample_size is not None:
        data = sample(data, k=args.sample_size)

X, Y = [], []
with ProcessPoolExecutor() as executor:
    for x, y in tqdm(executor.map(process_experiment, data), total=len(data)):
        X.append(x)
        Y.append(y)
X = np.asarray(X)
Y = np.asarray(Y)

def f(X, weights):
    # model weights
    base_kf = np.exp(weights[0])
    base_kcat = np.exp(weights[1])
    t1_adenosine_score = weights[2]
    ago2_deltaG = weights[3]
    kf_mismatches_penalties = expit(weights[4:])

    # model features
    t1_adenosine = X[:,0]
    seed_energy = X[:,1]
    central_bulge_size = X[:,2]
    tail_energy = X[:,3]
    cleavage_probability = X[:,4]
    kf_mismatches = X[:,5:]

    canonical_ensemble = [seed_energy, seed_energy + tail_energy]

    # free energy model
    deltaG = ago2_deltaG + (t1_adenosine * t1_adenosine_score) + binding_energy(canonical_ensemble, axis=0)

    kf = base_kf * np.prod(np.where(kf_mismatches, kf_mismatches_penalties, 1.), axis=1)
    # FIXME: this kcat should be conditioned on a supplementary bound
    kcat = base_kcat * cleavage_probability
    Kd = 1e12 * np.exp(deltaG / (R * T))
    kr = kf * Kd
    Km = Kd + (kcat/kf)
    return np.column_stack([kf, kr, kcat, Kd, Km])

def log_rmse(x, y):
    ix = np.isfinite(np.log(x)) & np.isfinite(np.log(y))
    return np.linalg.norm((np.log(x[ix]) - np.log(y[ix])) / np.count_nonzero(ix))

def log_r2(x, y):
    ix = np.isfinite(np.log(x)) & np.isfinite(np.log(y))
    return pearsonr(np.log(x)[ix], np.log(y)[ix])[0]**2

def loss(X, y, weights):
    return log_rmse(f(X, weights), y)

func = lambda weights: loss(X, Y, weights)

result = minimize(func, x0=np.asarray([np.log(1e-5), np.log(1.), -1., -5.] + 8 * [logit(0.5)]))
weights = result['x']

print(f'RMSE: {result["fun"]:.2f}')

for i, constant in enumerate(['kf', 'kr', 'kcat', 'Kd', 'Km']):
    r2 = log_r2(f(X, weights)[:,i], Y[:,i])
    print(f'{constant} RÂ²: {r2:.2f}')
print(f'''Optimal Parameters:
    base kf = {np.exp(weights[0]):.2e}
    base kcat = {np.exp(weights[1]):.2e}
    t1 adenosine contribution = {weights[2]:.2f} kcal/mol
    AGO2 entropy = {weights[3]:.2f} kcal/mol
    seed mismatch penalties = {expit(weights[4:])}''')
