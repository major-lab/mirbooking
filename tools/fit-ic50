#!/usr/bin/env python3

import gi
gi.require_version('Mirbooking', '2.3')
from gi.repository import GLib, Mirbooking
import pandas as pd
from autograd import grad, hessian
import autograd.numpy as np
from scipy.optimize import minimize
import gzip
from Bio.SeqIO import parse
import argparse
import sys

parser = argparse.ArgumentParser()
parser.add_argument('--targets', required=True)
parser.add_argument('--input', required=True)
parser.add_argument('--cutoff', type=float, default=100, required=True)
parser.add_argument('--output', default=sys.stdout)
args = parser.parse_args()

cutoff = args.cutoff

loss = lambda x, y: np.linalg.norm(x - y)

def logit(X, slope, ic50):
    return 1 / (1 + np.exp(-slope*(X - ic50)))

def fit(X, Y):
    X = np.array(X)
    Y = np.array(Y)
    assert np.isfinite(X).all()
    assert np.isfinite(Y).all()
    def f(params):
        slope, ic50 = params
        return loss(logit(X, slope, ic50), Y)
    return minimize(f, x0=[1, 0], jac=grad(f), hess=hessian(f), method='Newton-CG')

mir_934 = Mirbooking.Mirna(accession='MIMAT0004977', name='hsa-miR-934', sequence='UGUCUACUACUGGAGACACUGG')

st = Mirbooking.DefaultScoreTable(seed_scores=GLib.MappedFile('/home/guillaume/.local/share/mirbooking-2.3/scores-7mer-3mismatch-ending', False).get_bytes(),
                                  supplementary_model=Mirbooking.DefaultScoreTableSupplementaryModel.YAN_ET_AL_2018,
                                  supplementary_scores=GLib.MappedFile('/home/guillaume/.local/share/mirbooking-2.3/scores-3mer', False).get_bytes())

def bound_fraction(d):
    bf = d.quantity / d.target_quantity
    return 1-(1-bf).prod()

def expected_occupants(d):
    return (d.quantity / d.target_quantity).sum()

X = np.logspace(-5, 5, num=10)

quantification = pd.read_csv(args.input, sep='\t', names=('accession','quantity'), index_col='accession')

print('Reading targets...')
targets = {}
with gzip.open(args.targets, 'rt') as f:
    for record in parse(f, 'fasta'):
        target_accession, _, _, _, target_name, *_ = record.id.split('|')
        if target_accession in quantification.index:
            targets[target_accession] = Mirbooking.Target(accession=target_accession,
                    name=target_name,
                    sequence=record.seq)

print('Initializing the model...')
broker = Mirbooking.Broker(score_table=st, sparse_solver=Mirbooking.BrokerSparseSolver.MKL_LAPACK)
broker.set_sequence_quantity(mir_934, np.max(X))
ud = Mirbooking.DefaultScoreTableCutoffFilterUserData()
ud.broker = broker
ud.cutoff = cutoff
st.set_filter(Mirbooking.DefaultScoreTable.cutoff_filter, ud)
for t, quantity in quantification.quantity[quantification.quantity >= cutoff].items():
    broker.set_sequence_quantity(targets[t], quantity)
broker.evaluate()

print(f'{len(broker.get_occupants())} interactions')

print('Computing models...')
Y = []
for mq in X:
    print(f'Testing {mir_934.get_name()} at {mq:.0f} pM...')
    broker.set_sequence_quantity(mir_934, mq -  broker.get_bound_mirna_quantity(mir_934))
    while broker.evaluate()[1] > 1:
        broker.step(Mirbooking.BrokerStepMode.SOLVE_STEADY_STATE, 1)
    df = broker.get_target_sites_as_dataframe()
    Y.append(df.groupby('target_accession').apply(bound_fraction))

responses = pd.concat(Y, axis=1, sort=False).T

print('Fitting models...')
results = []
for target, titrations in responses.iteritems():
    # remove missing observations
    titrations = titrations.dropna()
    fit_result = fit(np.log10(X[-len(titrations):]), titrations)
    if fit_result.success:
        results.append((target, fit_result.x[0], np.power (10, fit_result.x[1])))
        print(f'{target} slope: {fit_result.x[0]:.2e} IC50: {np.power(10, fit_result.x[1]):.2e} pM')

pd.DataFrame(results, columns=['target_accession', 'slope', 'ic50']).set_index('target_accession').to_csv(args.output, sep='\t')
